/*  
 * Copyright 2004-2009 DTRules.com, Inc.
 *   
 * Licensed under the Apache License, Version 2.0 (the "License");  
 * you may not use this file except in compliance with the License.  
 * You may obtain a copy of the License at  
 *   
 *      http://www.apache.org/licenses/LICENSE-2.0  
 *   
 * Unless required by applicable law or agreed to in writing, software  
 * distributed under the License is distributed on an "AS IS" BASIS,  
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  
 * See the License for the specific language governing permissions and  
 * limitations under the License.  
 */
 
package com.dtrules.compiler.el.cup.parser;

import java.util.*;
import java.io.*;
import java_cup.runtime.*;
import com.dtrules.interpreter.IRObject;

action code {:
    
    public String left (java.util.Stack stack) {
       return ((RSymbol)stack.peek()).leftvalue;
    }   

    public void notlocal(java.util.Stack stack){
      Symbol v = (Symbol) stack.peek();
      if(v instanceof RSymbol && ((RSymbol)v).local){
          throw new RuntimeException("The Local Variable "+((RSymbol)v).rightvalue+" is being referenced improperly");
      }
    }
    /**
     * Provides the original text for the right side.
     **/
    public String rv(java.util.Stack stack){
       return ((RSymbol)stack.peek()).rightvalue;
    } 
:};

parser code {: 
 
  public int localCnt = 0;
  
  public HashMap<String,RLocalType> localtypes = new HashMap<String,RLocalType>();
  
  public void report_error(String message, Object info){}

   public final int      
                 iBoolean       = IRObject.iBoolean,
                 iString        = IRObject.iString,
                 iInteger       = IRObject.iInteger,
                 iDouble        = IRObject.iDouble,
                 iEntity        = IRObject.iEntity,
                 iName          = IRObject.iName,
                 iArray         = IRObject.iArray,
                 iDecisiontable = IRObject.iDecisiontable,
                 iNull          = IRObject.iNull,
                 iMark          = IRObject.iMark,
                 iOperator      = IRObject.iOperator,
                 iDate          = IRObject.iDate,
                 iTable         = IRObject.iTable,
                 iXmlValue      = IRObject.iXmlValue; 
    /**
     * Adds a symbol to the local variable hash, and
     * returns allocation code for the local variable.
     **/ 
    public String newLocal(String v, int type, String initialValue){
                v = v.toLowerCase();
                RLocalType t = new RLocalType();
                t.name       = v;
                t.index      = localCnt++;  
                t.type       = type;
                localtypes.put(v,t);
                if(initialValue != null){
                   return initialValue + "allocate execute deallocate pop ";
                }else{
                   return "null allocate execute ";
                }       
    }

:};


/* Terminals (tokens returned by the scanner). */
terminal String		ABSOLUTEVALUE, ACTION, ADD, AFTER, ALL, ALLOWING, AND, 
                    ARRAY, ARRAY_OF_VALUES, ASCENDINGORDER, ASSIGN, ATTRIBUTE, 
                    AT, BEFORE, BETWEEN, BOOL_FUNCTION, BOOLEAN, BY, CHANGE, CLEAR, 
					CLONE, COLON, CONTEXT, COMMA, CONDITION, COPY, CURRENT_DATE, 
					CURRENT_TIMESTAMP, CVS, DATE, DAYS, DEBUG, DECIMAL_PLACES, 
					DECREMENT, DEEPCOPY, DESCENDINGORDER, DIVIDE, DOES, DOUBLE, 
					EACH, EARLIEST, ELEMENT, ELSE, ELSEIF, ELSEIFNONEAREFOUND, 
					END, ENDIF, ENTITY, EQ, EQ_IGNORE_CASE, FIRST, FLOAT, FOR, 
					FORALL, FROM, GET, GT, GTE, HASA, HAVE, IF, IN, 
					INCLUDE, INCLUDES, INCREMENT, INDEX_OF, INTEGER, IS, 
					ISNOTNULL, ISNULL,	ITS, LBRACE, LCURLY, LENGTH, 
					LOCAL, LONG, LOWER_CASE, LPAREN,  LT, LTE, MAP, MAPPINGKEY, MATCH, 
					MATCHES, MEMBER, MINUS, MONTHS, MULTIPLY, NAME, 
					NAMEOF, NEQ, NEQ_IGNORE_CASE, NEW, NO, NOT, NUMBEROF, OF, ON, 
					ONE, ONERROR, OR, PERCENTOF, PERFORM, PLUS, PLUSORMINUS, 
					POLICYSTATEMENT, POLICYSTATEMENTS, POSSESSIVE, PRINT, 
				   QUESTIONMARK, RANDOMIZE, RARRAY, RBOOLEAN, RBRACE, 
					RCURLY, RDATE, RDECISIONTABLE, RDOUBLE, RELATIONSHIP_BETWEEN, 
					REMOVE, RENTITY, 
					RINVALID, RLONG, RNAME, RNULL, ROPERATOR, ROUNDED, RPAREN, 
					RSTRING, RTABLE, RXMLVALUE, SEMI, SET, SORT, STARTS_WITH,  
					STRING, SUBSTRING, SUBTRACT, SUM_OF, TABLE, TABLEINFORMATION, 
					THEN, THENAME, THERE, THIS, TIMES, THROUGH, TO, 
					TOBEREMOVED,
					TOKENIZE, TRIM, UMINUS, UNDEFINED, UPPER_CASE, USING, VALUE, 
					WAS, WHERE, WITHIN, WITH_BOUNDRY, YEARS, YEAROF; 
 
terminal String		IDENT; 	// This one is used by the Lexical Analyzer, so it is 
							// unreferrenced in the parser.  We still need it.
							
/* Non terminals */

non terminal String     done, statement_list, statement;
non terminal String     number; 
non terminal String     inthe;
non terminal String     iexpr, fexpr, bexpr, eexpr, nexpr, texpr, strexpr, indx_expr;
non terminal String     dexpr;
non terminal String     array_expr, array_expr2;
non terminal String 	includeSearch;


non terminal String     forblock;
non terminal String     forallblock;

non terminal String     forctl;
non terminal String     forallctl, forfirstctl;
non terminal String     ifblock;
non terminal String     usingblock;
non terminal String     firstblock;
non terminal String     block;
non terminal String     thereis;


non terminal String     setstatement;
non terminal String     usingstatement;
non terminal String     performstatement;
non terminal String     debugstatement;
non terminal String     ifstatement;
non terminal String     addtostatement, addtodest, addtodest2, subtodest;
non terminal String     clearstatement;    
non terminal String     randomstatements; 
non terminal String     commonerror;
non terminal String     tablelist;
non terminal String     operatorlist;
non terminal String     operatorstatements;
non terminal String     contextstatement;
non terminal String     localvariables;
non terminal String     context_for_table;
non terminal String     datestatement;
non terminal String     xmlvalues;
non terminal String     xmlvaluestatements;
non terminal String     separator;


non terminal String     blist, blist_ic;

non terminal String     ifcontinue,
                        left_iexpr,
                        left_fexpr,  
                        left_bexpr,
                        left_eexpr,
                        left_strexpr,
                        left_dexpr,
                        left_ArrayRef,
                        left_texpr,
                        colonRef,
                        possessiveRef,
                        array_lit,
                        array_list;
                        
                        
/* Precedences */

precedence left RARRAY,RLONG,RBOOLEAN,RENTITY,RSTRING;
precedence right SEMI, ACTION, WHERE, OF;
precedence left ASSIGN,RCURLY,LCURLY;
precedence left LBRACE, RBRACE, FORALL;
precedence left IF, THEN, ELSE, ENDIF;
precedence left OR, COMMA, DEBUG;
precedence left AND;
precedence left EQ,NEQ,GT,LT,GTE,LTE,ISNULL,ISNOTNULL;
precedence right ROUNDED, TO;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;
precedence left IS, NOT, UMINUS, LPAREN, RPAREN, TRIM, STRING;
precedence left USING, POSSESSIVE, COLON;
 



/* The grammar */




done ::=
      ACTION SEMI                    {: RESULT = ""; :} // We allow blank values for all sections.
      |                                                 // This allows us to comment out statements.
      CONDITION SEMI                 {: RESULT = ""; :}
      |
      CONTEXT SEMI                   {: RESULT = ""; :}
      |
      POLICYSTATEMENT SEMI           {: RESULT = ""; :}
      |
      ACTION statement_list:e                      {: RESULT = "\n"+e+"\n"; :}
	  |
      CONDITION bexpr:e                       SEMI {: RESULT = "\n"+e+"\n"; :}
      |
      CONDITION debugstatement:d SEMI bexpr:e SEMI {: RESULT = "\n"+d+e+"\n"; :}
      |
      CONDITION bexpr:e SEMI debugstatement:d SEMI {: RESULT = "\n"+e+d+"\n"; :} 
      |
      CONTEXT context_for_table:e             SEMI {: RESULT = "\n"+e+"\n"; :} 
      |
      CONTEXT debugstatement:d SEMI context_for_table:e SEMI {: RESULT = "\n"+d+e+"\n"; :} 
      |
      POLICYSTATEMENT strexpr:e               SEMI {: RESULT = e; :}
      |
      POLICYSTATEMENT nexpr:e                 SEMI {: RESULT = e; :}
      |
      POLICYSTATEMENT iexpr:e                 SEMI {: RESULT = e; :}
      |
      POLICYSTATEMENT fexpr:e                 SEMI {: RESULT = e; :}
      |
      POLICYSTATEMENT bexpr:e                 SEMI {: RESULT = e; :}
      |
      POLICYSTATEMENT dexpr:e                 SEMI {: RESULT = e; :}
      |
      IDENT     // This is bogus, cause the TokenFilter is going to filter out any IDENT matches.     
      ;         // But this gets rid of the warning.
               
statement_list ::= statement_list:e1 block:e2     {: RESULT = e1+e2;            :} |
                   block:e                        {: RESULT = e;                :} ;
                   
separator ::= SEMI | COMMA ;                  
                   
statement ::=  setstatement:e       separator {: RESULT = e;         :} |
			   performstatement:e   separator {: RESULT = e;         :} |
               debugstatement:e     separator {: RESULT = e;         :} |
               ifstatement:e        separator {: RESULT = e;         :} |
			   addtostatement:e     separator {: RESULT = e;         :} |
               clearstatement:e     separator {: RESULT = e;         :} |
               usingstatement:e     separator {: RESULT = e;         :} |
               randomstatements:e   separator {: RESULT = e;         :} |
               commonerror:e        separator {: RESULT = e;         :} |
               operatorstatements:e separator {: RESULT = e;         :} |
               contextstatement:e   separator {: RESULT = e;         :} |
               datestatement:e      separator {: RESULT = e;         :} |
               xmlvaluestatements:e separator {: RESULT = e;         :} ;
                   
usingblock   ::= RENTITY:ee        usingblock:e               {: RESULT = ee + " entitypush "+e+"entitypop ";  :} |
                 RENTITY:ee COMMA  usingblock:e               {: RESULT = ee + " entitypush "+e+"entitypop ";  :} |
                 block:e                                      {: RESULT = e; :} ; 

// To make this work, the token filter has to inject a token after every possessive parsed, and
// I chose a COMMA for that token
possessiveRef ::= POSSESSIVE:e1 COMMA possessiveRef:e2        {: RESULT = e1 +" entitypush "+e2+"entitypop "; :} |
                  POSSESSIVE:e  COMMA                         {: RESULT = e+" ";                              :} |
                  COLON RENTITY:e1 COLON possessiveRef:e2     {: RESULT = e1 +" entitypush "+e2+"entitypop "; :} |
                  COLON RENTITY:e1 COLON                      {: RESULT = e1 +" ";                            :} ;
                            
colonRef      ::= possessiveRef:e                             {: RESULT = e; :} ;

forallblock ::= block:blk forallctl:ctl 
				  {: RESULT = "{ "+blk+"} "+ctl+"pop "; :};

context_for_table ::= debugstatement:e      {: RESULT = e+"execute ";            :} |
					  forctl:ctl            {: RESULT = ctl+"pop ";              :} |
                      forallctl:ctl 		{: RESULT = ctl+"pop "; 			 :} |
					  forfirstctl:ctl 		{: RESULT = ctl+"pop "; 			 :} |
					  contextstatement:c 	{: RESULT = c +"execute entitypop "; :} |
					  localvariables:v      {: RESULT = v;                       :} ;
					  
localvariables ::=
            LOCAL ENTITY UNDEFINED:v                  {: RESULT = parser.newLocal(v, parser.iEntity, null);                     :} | 
			LOCAL ENTITY UNDEFINED:v ASSIGN eexpr:e   {: RESULT = parser.newLocal(v, parser.iEntity, e + "cve ");               :} |
			LOCAL ENTITY RENTITY:v                    {: if(true)throw new RuntimeException(
			                                        "The variable '"+rv(CUP$DTRulesParser$stack)+"' is already defined"); :} |
			                                        		  
            LOCAL LONG   UNDEFINED:v                  {: RESULT = parser.newLocal(v, parser.iInteger, null);                    :} | 
            LOCAL LONG   UNDEFINED:v ASSIGN number:e  {: RESULT = parser.newLocal(v, parser.iInteger, e + "cvi ");              :} |
            LOCAL LONG   RLONG:v                      {: if(true)throw new RuntimeException(
                                                    "The variable '"+rv(CUP$DTRulesParser$stack)+"' is already defined"); :} |          

            LOCAL DOUBLE UNDEFINED:v                  {: RESULT = parser.newLocal(v, parser.iDouble, null);                     :} | 
            LOCAL DOUBLE UNDEFINED:v ASSIGN number:e  {: RESULT = parser.newLocal(v, parser.iDouble, e + "cvr ");               :} |
            LOCAL DOUBLE RDOUBLE:v                    {: if(true)throw new RuntimeException(
                                                    "The variable '"+rv(CUP$DTRulesParser$stack)+"' is already defined"); :} |
                                                    
            LOCAL BOOLEAN UNDEFINED:v                 {: RESULT = parser.newLocal(v, parser.iBoolean, null);                    :} | 
            LOCAL BOOLEAN UNDEFINED:v ASSIGN bexpr:e  {: RESULT = parser.newLocal(v, parser.iBoolean, e + "cvb ");              :} |
            LOCAL BOOLEAN RBOOLEAN:v                  {: if(true)throw new RuntimeException(
                                                    "The variable '"+rv(CUP$DTRulesParser$stack)+"' is already defined"); :} |

            LOCAL DATE UNDEFINED:v                    {: RESULT = parser.newLocal(v, parser.iDate, null);                       :} | 
            LOCAL DATE UNDEFINED:v ASSIGN dexpr:e     {: RESULT = parser.newLocal(v, parser.iDate, e + "cvd ");                 :} |
            LOCAL DATE RDATE:v                        {: if(true)throw new RuntimeException(
                                                    "The variable '"+rv(CUP$DTRulesParser$stack)+"' is already defined"); :} |
                                                    
            LOCAL ARRAY UNDEFINED:v                     {: RESULT = parser.newLocal(v, parser.iArray, null);                    :} | 
            LOCAL ARRAY UNDEFINED:v ASSIGN array_expr:e {: RESULT = parser.newLocal(v, parser.iArray, e);                       :} |
            LOCAL ARRAY RARRAY:v                        {: if(true)throw new RuntimeException(
                                                    "The variable '"+rv(CUP$DTRulesParser$stack)+"' is already defined"); :} |

            LOCAL STRING UNDEFINED:v                  {: RESULT = parser.newLocal(v, parser.iString, null);                     :} | 
            LOCAL STRING UNDEFINED:v ASSIGN strexpr:e {: RESULT = parser.newLocal(v, parser.iString, e + "cvs ");               :} |
            LOCAL STRING RSTRING:v                    {: if(true)throw new RuntimeException(
                                                    "The variable '"+rv(CUP$DTRulesParser$stack)+"' is already defined"); :} ;          

					  
// Only use the IF statement in extreme circumstances.
ifstatement ::=
             IF bexpr:b THEN block:blk1 ENDIF                     {: RESULT = "{ "+blk1+"} "             +b+ "if "    ; :} |					  
			 IF bexpr:b THEN block:blk1 ELSE block:blk2 ENDIF     {: RESULT = "{ "+blk1+"} { "+blk2+"} " +b+ "ifelse "; :} ;
		

// The Control statements assume the object that should be executed as
// described by the following statements is provided on the stack, 
// and that object should be left on the stack
forallctl   ::=
              FORALL array_expr:a 
                  {: RESULT = "dup "+a+"forall "; :}
              |
              FORALL array_expr:a ALLOWING array_expr TOBEREMOVED
                  {: RESULT = "dup "+a+"forallr "; :}
              |
              FORALL array_expr:a IN eexpr:ev  
                  {: RESULT = "dup "+ev+" entitypush "+a+"forall entitypop "; :}
              |
              FORALL array_expr:a IN eexpr:ev  ALLOWING array_expr TOBEREMOVED
                  {: RESULT = "dup "+ev+" entitypush "+a+"forallr entitypop "; :}
              |
              FORALL array_expr:a IN eexpr:e2 WHERE bexpr:b 
                  {: RESULT = "{ dup "+b+"if } "+e2+" entitypush "+a+"forall entitypop "; :} 
              |
              FORALL array_expr:a WHERE bexpr:b 
                  {: RESULT = "{ dup "+b+"if } "+a+"forall "; :}
              |
              FORALL array_expr:a WHERE bexpr:b ALLOWING array_expr TOBEREMOVED
                  {: RESULT = "{ dup "+b+"if } "+a+"forallr "; :}
              ;

forblock ::=  
			  
              array_expr:a block:blk                  
                  {: RESULT = "{ "+blk+"} "+a+"forallr "; :}
              |
              eexpr:ev IN array_expr:a block:blk
                  {: RESULT = "{ "+blk+"} "+a+" forallr "; :}
              |
              eexpr:e2 IN array_expr:a WHERE bexpr:b block:blk
                  {: RESULT = "{ { "+blk+" } "+b+"if } "+a+"forallr "; :} 
              |
              array_expr:a WHERE bexpr:b block:blk
                  {: RESULT = "{ { "+blk+" } "+b+"if } "+a+"forallr "; :}
              |
              eexpr AND ITS eexpr:e2 IN array_expr:a block:blk
                  {: RESULT = "{ "+e2+"entitypush "+blk+" entitypop } "+a+" forallr "; :}
              |
              eexpr AND ITS eexpr:e2 IN array_expr:a WHERE bexpr:b block:blk
                  {: RESULT = "{ "+e2+"entitypush { "+blk+" } "+b+"if entitypop } "+a+"forallr "; :} 
              ;



// Takes the "Then" clause on the data stack.
forfirstctl ::= FOR FIRST OF array_expr:a WHERE bexpr:test 
               {: RESULT = "dup { "+test+" } "+a+" forfirst "; :} 
               |
               FOR FIRST OF array_expr:a AND ITS eexpr:e1 WHERE bexpr:test 
               {: RESULT = "{ "+e1+" entitypush dup execute entitypop } { "+e1+" entitypush "+test+" entitypop } "+a+" forfirst "; :} 
               |
               FOR FIRST IN array_expr:a WHERE bexpr:test 
               {: RESULT = "dup { "+test+" } "+a+" forfirst "; :} ;


firstblock ::= FOR FIRST OF array_expr:a WHERE bexpr:test THEN block:body1 ELSEIFNONEAREFOUND block:body2
               {: RESULT = "{ "+body1+" } { "+body2+" } { "+test+" } "+a+" forfirstelse "; :} 
               |
               FOR FIRST OF array_expr:a AND ITS eexpr:e1 WHERE bexpr:test THEN block:body1 ELSEIFNONEAREFOUND block:body2
               {: RESULT = "{ "+e1+" entitypush "+body1+"entitypop } { "+body2+" } { "+e1+" entitypush "+test+"entitypop } "+a+" forfirstelse "; :} 
               |
               forfirstctl:ctl THEN block:body
               {: RESULT = "{ "+body+" } "+ctl+ "pop "; :} 
               ;

			

block        ::= LCURLY statement_list:e RCURLY      {: RESULT = e+"\n";  :} |
                 USING usingblock:e                  {: RESULT = e;       :} |
                 forallblock:e                       {: RESULT = e;       :} |
                 FORALL forblock:e                   {: RESULT = e;       :} |
                 firstblock:e                        {: RESULT = e;       :} |
                 IF ifblock:e                        {: RESULT = e;       :} |
                 block:e separator                   {: RESULT = e;       :} |
                 statement:e                         {: RESULT = e;       :} ;
                 				               

                   
usingstatement ::= USING usingblock:ee separator {: RESULT = ee ; :} ;
               
/**
 * Because we also have local variables, we let the tokenizer pick the code used to 
 * popluate the value of a left side expression.
 **/                                 
left_iexpr     ::= RLONG:v                                  {: RESULT = left(CUP$DTRulesParser$stack)+" ";                     :} |
                   colonRef:e left_iexpr:v                  {: notlocal(CUP$DTRulesParser$stack); RESULT = e+"entitypush "+v+"entitypop ";        :} ;
left_fexpr     ::= RDOUBLE:v                                {: RESULT = left(CUP$DTRulesParser$stack)+" ";                     :} |
                   colonRef:e left_fexpr:v                  {: notlocal(CUP$DTRulesParser$stack); RESULT = e+"entitypush "+v+"entitypop ";        :} ;
left_bexpr     ::= RBOOLEAN:v                               {: RESULT = left(CUP$DTRulesParser$stack)+" ";                     :} |
                   colonRef:e left_bexpr:v                  {: notlocal(CUP$DTRulesParser$stack); RESULT = e+"entitypush "+v+"entitypop ";        :} ;                    
left_eexpr     ::= RENTITY:v                                {: RESULT = left(CUP$DTRulesParser$stack)+" ";                     :} |
                   colonRef:e left_eexpr:v                  {: notlocal(CUP$DTRulesParser$stack); RESULT = e+"entitypush "+v+"entitypop ";        :} ;
left_strexpr   ::= RSTRING:v                                {: RESULT = left(CUP$DTRulesParser$stack)+" ";                     :} |
                   colonRef:e left_strexpr:v                {: notlocal(CUP$DTRulesParser$stack); RESULT = e+"entitypush "+v+"entitypop ";        :} ;
left_dexpr     ::= RDATE:v                                  {: RESULT = left(CUP$DTRulesParser$stack)+" ";                     :} |
                   colonRef:e  left_dexpr:v                 {: notlocal(CUP$DTRulesParser$stack); RESULT = e+"entitypush "+v+"entitypop ";        :} ;
left_texpr     ::= RTABLE:v                                 {: RESULT = left(CUP$DTRulesParser$stack)+" ";                     :} |
                   colonRef:e left_texpr:v                  {: notlocal(CUP$DTRulesParser$stack); RESULT = e+"entitypush "+v+"entitypop ";        :} ;

//
// Punt on type checking on values assigned to typed arrays.
//
left_ArrayRef         ::= RARRAY:a                          {: RESULT = left(CUP$DTRulesParser$stack);                         :} |
                          colonRef:e left_ArrayRef:v        {: notlocal(CUP$DTRulesParser$stack); RESULT = e+"entitypush "+v+"entitypop ";    :} ;

setstatement ::= SET left_iexpr:v    ASSIGN number:e   {:        RESULT = e+"cvi "+v; :} |
                 SET left_fexpr:v    ASSIGN number:e   {:        RESULT = e+"cvr "+v; :} |  
                 SET left_bexpr:v    ASSIGN bexpr:e    {:        RESULT = e+"cvb "+v; :} |
                 SET left_eexpr:v    ASSIGN eexpr:e    {:        RESULT = e+"cve "+v; :} | 
                 SET left_strexpr:v  ASSIGN strexpr:e  {:        RESULT = e+"cvs "+v; :} |
                 SET left_strexpr:v  ASSIGN number:e   {:        RESULT = e+"cvs "+v; :} |
                 SET left_strexpr:v  ASSIGN dexpr:e    {:        RESULT = e+"cvs "+v; :} |
                 SET left_strexpr:v  ASSIGN nexpr:e    {:        RESULT = e+"cvs "+v; :} |
                 SET left_strexpr:v  ASSIGN texpr:e    {:        RESULT = e+"cvs "+v; :} |
                 SET left_bexpr:v    ASSIGN nexpr:e    {:        RESULT = e+"cvb "+v; :} |
                 SET left_dexpr:v    ASSIGN dexpr:e    {:        RESULT = e+"cvd "+v; :} |   
				 SET left_texpr:v    ASSIGN texpr:e    {:        RESULT = e       +v; :} |

                 SET left_ArrayRef:v     ASSIGN eexpr:e               {:  RESULT = e+v; :} |
                 SET left_ArrayRef:v     ASSIGN strexpr:e             {:  RESULT = e+v; :} |
                 SET left_ArrayRef:v     ASSIGN fexpr:e               {:  RESULT = e+v; :} |
                 SET left_ArrayRef:v     ASSIGN iexpr:e               {:  RESULT = e+v; :} |
                 SET left_ArrayRef:v     ASSIGN dexpr:e               {:  RESULT = e+v; :} |
                 SET left_ArrayRef:v     ASSIGN array_expr:e          {:  RESULT = e+v; :} |

                 INCREMENT RLONG:v       {: RESULT = v+" 1 ladd " + left(CUP$DTRulesParser$stack);  :} |
                 INCREMENT RDOUBLE:v     {: RESULT = v+" 1 dadd " + left(CUP$DTRulesParser$stack);  :} |
                 DECREMENT RLONG:v       {: RESULT = v+" 1 lsub " + left(CUP$DTRulesParser$stack);  :} |
                 DECREMENT RDOUBLE:v     {: RESULT = v+" 1 dsub " + left(CUP$DTRulesParser$stack); :} 
	      ;

// Java like for statement
forctl          ::= FOR left_iexpr:v ASSIGN number:e SEMI bexpr:b SEMI statement:s     
                    {: RESULT = e+"cvi "+v+"{ dup execute "+s+"execute } "+b+"while "; :}
                ; 
 

performstatement ::=  
                PERFORM RDECISIONTABLE:dt1 AND ONERROR ADD eexpr:e TO CONTEXT AND PERFORM RDECISIONTABLE:dterror
                    {: RESULT = "/"+dt1+" lookup /"+dterror+" lookup "+e+" PerformCatchError "; :} |
                RDECISIONTABLE:dt         {: RESULT = dt+" ";   :} |
                PERFORM RDECISIONTABLE:dt {: RESULT = dt+" ";   :} |
                PERFORM NAME:dt           {: RESULT = dt+" ";   :} ;
                
                      
                                             
debugstatement ::=
              DEBUG strexpr:s             {: RESULT = s+"debug "; :} |
              DEBUG bexpr:s               {: RESULT = s+"debug "; :} |
              DEBUG iexpr:s               {: RESULT = s+"debug "; :} |
              DEBUG fexpr:s               {: RESULT = s+"debug "; :} |
              DEBUG eexpr:s               {: RESULT = s+"debug "; :} |
              DEBUG dexpr:s               {: RESULT = s+"debug "; :} |
              DEBUG array_expr:s          {: RESULT = s+"debug "; :} |
              
              PRINT strexpr:s             {: RESULT = s+"debug "; :} |
              PRINT bexpr:s               {: RESULT = s+"debug "; :} |
              PRINT iexpr:s               {: RESULT = s+"debug "; :} |
              PRINT fexpr:s               {: RESULT = s+"debug "; :} |
              PRINT eexpr:s               {: RESULT = s+"debug "; :} |
              PRINT dexpr:s               {: RESULT = s+"debug "; :} |
              PRINT array_expr:s          {: RESULT = s+"debug "; :} ;


ifblock     ::= bexpr:b THEN statement_list:e1 ifcontinue:e2 
                   {: if(e2.trim().length()>0) {
                            RESULT= "{ "+e1+"} {"+e2+"} "+b+"ifelse "; 
                      }else{
                            RESULT= "{ "+e1+"} "+b+"if ";
                      }
                   :};

ifcontinue  ::= ENDIF                          {: RESULT=""; :} |
                ELSE statement_list:e1 ENDIF   {: RESULT=e1; :} |
                ELSEIF ifblock:e               {: RESULT=e;  :} ;
                                            

                
number    ::= iexpr:v           {: RESULT = v+" "; :} |
              fexpr:v           {: RESULT = v+" "; :} 
              ;
   
              
              
/** Array types **/              
   
addtodest2    ::= array_expr2:a                              {: RESULT = a+"swap addto ";                          :} |
                  RLONG:a                                    {: RESULT = a+" + " +left(CUP$DTRulesParser$stack);   :} |
                  RDOUBLE:a                                  {: RESULT = a+" f+ "+left(CUP$DTRulesParser$stack);   :} ;
                  
addtodest     ::= array_expr2:a                              {: RESULT = a+"swap addto ";                          :} |
                  RLONG:a                                    {: RESULT = a+" + " +left(CUP$DTRulesParser$stack);   :} |
 				  RDOUBLE:a	                                 {: RESULT = a+" f+ "+left(CUP$DTRulesParser$stack);   :} |
                  colonRef:e addtodest2:v                    {: notlocal(CUP$DTRulesParser$stack); RESULT = e+"entitypush "+v+"entitypop ";        :} ;
                   
subtodest     ::= RLONG:a                                    {: RESULT = a+" swap - "  +left(CUP$DTRulesParser$stack); :} | 
 				  RDOUBLE:a	                                 {: RESULT = a+" swap f- " +left(CUP$DTRulesParser$stack); :} |             
                  colonRef:e addtodest2:v                    {: notlocal(CUP$DTRulesParser$stack); RESULT = e+"entitypush "+v+"entitypop ";        :} ;
 
addtostatement ::=               
			  ADD array_expr:a1           TO array_expr:a2  IF NOT MEMBER    {: RESULT =a1+a2+"false addarray "; :} |
              ADD array_expr:a1           TO array_expr:a2                   {: RESULT =a1+a2+"true  addarray "; :} |
              ADD eexpr:e                 TO addtodest:a                     {: RESULT =e+a;                    :} |
              ADD eexpr:e                 TO addtodest:a AND TO addtodest:a2 {: RESULT =e+"dup "+a+a2;          :} |
              ADD strexpr:e               TO addtodest:a                     {: RESULT =e+a;                    :} |
              ADD strexpr:e               TO addtodest:a AND TO addtodest:a2 {: RESULT =e+"dup "+a+a2;          :} |
              ADD dexpr:e                 TO addtodest:a                     {: RESULT =e+a;                    :} |
              ADD dexpr:e                 TO addtodest:a AND TO addtodest:a2 {: RESULT =e+"dup "+a+a2;          :} |
              ADD number:v                TO addtodest:a                     {: RESULT =v+a ;                   :} |
              ADD number:v                TO addtodest:a AND TO addtodest:a2 {: RESULT =v+"dup "+a+a2;          :} |

              
              SUBTRACT number:v         FROM subtodest:a      {: RESULT =v+a ;                   :} |     
              
              ADD eexpr:e IF NOT MEMBER   TO array_expr:a     {: RESULT =a+" "+e+"add_no_dups "; :} |
              ADD eexpr:e IF NOT MEMBER   TO array_expr:a AND TO array_expr:a2
              											      {: RESULT =e+a+"over add_no_dups "+a2+"swap add_no_dups "; :} |
              ADD strexpr:e IF NOT MEMBER TO array_expr:a     {: RESULT =a+" "+e+"add_no_dups "; :} |
              ADD strexpr:e IF NOT MEMBER TO array_expr:a AND TO array_expr:a2
              											      {: RESULT =e+a+"over add_no_dups "+a2+"swap add_no_dups "; :} ;
             
contextstatement ::=
			  ADD eexpr:e TO CONTEXT OF THIS TABLE            {: RESULT =e+"entitypush "; :} |
		      ADD eexpr:e TO CONTEXT FOR THIS TABLE           {: RESULT =e+"entitypush "; :} ;


					//"sortentities" Signature: 
					// ( array field boolean -- ) 
randomstatements ::=
              REMOVE iexpr:i   ELEMENT FROM array_expr:a ARRAY        {: RESULT = a+i+"removeat pop ";                :} |
              REMOVE EACH eexpr:e FROM array_expr:a WHERE bexpr:b     {: RESULT = a+"{ { dup 0 entityfetch remove pop } "+b+"if } over forallr pop"; :} | 
              REMOVE nexpr:i   FROM array_expr:a ARRAY                {: RESULT = a+i+"remove pop ";                  :} |
              REMOVE strexpr:i FROM array_expr:a ARRAY                {: RESULT = a+i+"remove pop ";                  :} |
              REMOVE eexpr:i   FROM array_expr:a ARRAY                {: RESULT = a+i+"remove pop ";                  :} |
              RANDOMIZE array_expr:a                                  {: RESULT = a+"randomize ";                     :} |
              CLEAR array_expr:a                                      {: RESULT = a+"clear ";                         :} |
              SORT array_expr:a IN ASCENDINGORDER BY nexpr:f          {: RESULT = a+f+"true sortentities ";           :} |
              SORT array_expr:a IN DESCENDINGORDER BY nexpr:f         {: RESULT = a+f+"false sortentities ";          :} ;
                                                                     

operatorlist ::= strexpr:s COMMA operatorlist:l     {: RESULT = l+s; :} 	|
				 iexpr:i COMMA operatorlist:l       {: RESULT = l+i; :} 	|
				 fexpr:f COMMA operatorlist:l       {: RESULT = l+f; :} 	|
				 eexpr:e COMMA operatorlist:l       {: RESULT = l+e; :} 	|
				 strexpr:s 							{: RESULT = s; :} 	    |
				 iexpr:i   							{: RESULT = i; :} 	    |
				 fexpr:f   							{: RESULT = f; :} 	    |
				 eexpr:e   							{: RESULT = e; :} 	    ;

operatorstatements ::=
              ROPERATOR:op LPAREN operatorlist:l RPAREN     {: RESULT = l+" "+op+" "; :} ;

xmlvalues ::= strexpr:v                                {: RESULT = v; :} |
              iexpr:v                                  {: RESULT = v; :} |
              fexpr:v                                  {: RESULT = v; :} |
              dexpr:v                                  {: RESULT = v; :} |
              nexpr:v                                  {: RESULT = v; :} ;
              
              // start_date: set the attribute "error" = "Invalid blah blah" 
xmlvaluestatements ::=
              RXMLVALUE:t COLON SET ATTRIBUTE strexpr:s1 ASSIGN xmlvalues:s2 {: RESULT = t+" "+s1+s2+"setXmlAttribute "; :} |
              eexpr:t     COLON SET ATTRIBUTE strexpr:s1 ASSIGN xmlvalues:s2 {: RESULT = t+" "+s1+s2+"setXmlAttribute "; :} |
              // Add attribute adds a comma delimited value to a possibly existing value for that attribute
              RXMLVALUE:t COLON ADD ATTRIBUTE strexpr:s1 ASSIGN xmlvalues:s2 {: RESULT = t+" "+s1+s2+"setXmlAttribute "; :} |
              eexpr:t     COLON ADD ATTRIBUTE strexpr:s1 ASSIGN xmlvalues:s2 {: RESULT = t+" "+s1+s2+"setXmlAttribute "; :} ;
 
// Array expressions

array_expr ::= 
              POLICYSTATEMENTS                              {: RESULT = "policystatements ";              :} |
              colonRef:e RARRAY:v                           {: RESULT = e+"entitypush "+v+" entitypop ";  :} |
              array_expr2:a                                 {: RESULT = a;                                :} ; 
              
array_expr2 ::=
              MAP array_expr:a THROUGH texpr:t              {: RESULT = t+a+"false translate ";           :} |
              LPAREN array_expr:a RPAREN                    {: RESULT = a;                                :} |
              RARRAY:e                                      {: RESULT = e+" ";                            :} |
              LPAREN ARRAY RPAREN NAME:n                    {: RESULT = n+" ";                            :} | 
              GET COPY OF array_expr:e                      {: RESULT = e+"copyelements ";                :} | 
              COPY OF array_expr:e                          {: RESULT = e+"copyelements ";                :} | 
              GET DEEPCOPY OF array_expr:e                  {: RESULT = e+"deepcopy ";                    :} |
              DEEPCOPY OF array_expr:e                      {: RESULT = e+"deepcopy ";                    :} | 
              array_lit:l                                   {: RESULT = l;                                :} |
              ARRAY_OF_VALUES LBRACE array_list:e RBRACE    {: RESULT = "mark "+e+" arraytomark ";        :} |
              TOKENIZE strexpr:s1 BY strexpr:s2             {: RESULT = s1+s2+"tokenize ";                :} ;         

array_lit ::= LBRACE array_list:l RBRACE                     {: RESULT = "{ "+l+"} ";                     :} ;

array_list ::= array_list:l COMMA strexpr:s                 {: RESULT = l+s;                             :} |
              array_list:l COMMA iexpr:s                    {: RESULT = l+s;                             :} |
              array_list:l COMMA eexpr:s                    {: RESULT = l+s;                             :} |
              array_list:l COMMA fexpr:s                    {: RESULT = l+s;                             :} |
              array_list:l COMMA nexpr:s                    {: RESULT = l+s;                             :} |
              nexpr:s                                       {: RESULT = s;                               :} |
              fexpr:s                                       {: RESULT = s;                               :} |
              eexpr:s                                       {: RESULT = s;                               :} |
              iexpr:s                                       {: RESULT = s;                               :} |
              strexpr:s                                     {: RESULT = s;                               :} ;
              
              
indx_expr     ::= 
              array_expr:ra LBRACE iexpr:ie1 RBRACE        {: RESULT = ra + ie1 + "getat "; :} ;
              
              

              
// Entity expressions 
eexpr    ::=  RENTITY:e                                     {: RESULT = e+" ";                               :} |           	
              LPAREN eexpr:e RPAREN                         {: RESULT = e;                                   :} | 
			  indx_expr:ie                                  {: RESULT = ie;                                  :} |	
			  NEW nexpr:n ENTITY                            {: RESULT = n+ " createentity ";                 :} |
			  NEW RENTITY:n ENTITY                          {: RESULT = "/"+n + " createentity ";            :} |
              CLONE OF eexpr:e                              {: RESULT = e+ "clone ";                         :} |
              colonRef:e1 RENTITY:e2                        {: RESULT = e1 +"entitypush "+e2+" entitypop ";  :} |
			  LPAREN ENTITY RPAREN RTABLE:t LPAREN tablelist:keys RPAREN 
                                                            {: RESULT = t + " " + keys + "lookup ";          :} |
      
              FIRST eexpr:e IN array_expr:a WHERE bexpr:b   {: RESULT = "{ "+e+"} { null } { "+b+"} "+a+"forfirstelse "; :} |
              FIRST eexpr:e WHERE bexpr:b                   {: RESULT = "{ "+e+"} { null } { "+b+"} "+e.trim()+"s forfirstelse "; :} |
              
			// relationship Relationship Syntax                                                            
              strexpr:s OF eexpr:e                          {: RESULT = "{ source } { null } { "+s+"type == } forfirstelse "; :} ;                                              


datestatement ::=
			  SUBTRACT number:i YEARS  FROM RDATE:v     {: RESULT = v +" "+ i +"negate addyears /"+v+" xdef ";  :} | 
			  SUBTRACT number:i MONTHS FROM RDATE:v     {: RESULT = v +" "+ i +"negate addmonths /"+v+" xdef "; :} | 
			  SUBTRACT number:i DAYS   FROM RDATE:v     {: RESULT = v +" "+ i +"negate adddays /"+v+" xdef ";   :} | 
			  ADD      number:i YEARS  TO   RDATE:v     {: RESULT = v +" "+ i +"addyears /"+v+" xdef ";         :} | 
			  ADD      number:i MONTHS TO   RDATE:v     {: RESULT = v +" "+ i +"addmonths /"+v+" xdef ";        :} | 
			  ADD      number:i DAYS   TO   RDATE:v     {: RESULT = v +" "+ i +"adddays /"+v+" xdef ";          :} ; 
                                                                     
// Date expressions

dexpr    ::=  LPAREN dexpr:e RPAREN                  {: RESULT = e+" ";                              :} |
			  RDATE:e                                {: RESULT = e+" ";                              :} |
              LPAREN DATE RPAREN strexpr:s           {: RESULT = s+"cvd ";                       :} |
              DATE LPAREN strexpr:s RPAREN           {: RESULT = s+"cvd ";                       :} | 
			  LPAREN DATE RPAREN indx_expr:ie        {: RESULT = ie;                                 :} |
			  LPAREN DATE RPAREN RARRAY:ra LBRACE iexpr:ie1 RBRACE {: RESULT = ra+" "+ie1+"getat ";  :} |
		      USING eexpr:ee  LPAREN dexpr:e RPAREN  {: RESULT = ee + "entitypush "+e+"entitypop ";  :} |
              colonRef:e1 RDATE:d                    {: RESULT = e1 +"entitypush "+d+" entitypop ";  :} |
              LPAREN number:n DAYS RPAREN            {: RESULT = n  +"days ";                        :} |               
              dexpr:d1 PLUS dexpr:d2                 {: RESULT = d1 +d2+"d+ ";                       :} |
              dexpr:d1 MINUS dexpr:d2                {: RESULT = d1 +d2+"d- ";                       :} |
			  LPAREN DATE RPAREN RTABLE:t LPAREN tablelist:keys RPAREN 
			  							             {: RESULT = t + " " + keys + "lookup ";         :} |
			  SUBTRACT number:i YEARS  FROM dexpr:v  {: RESULT = v +" "+i +"negate addyears ";       :} |
              SUBTRACT number:i MONTHS FROM dexpr:v  {: RESULT = v +" "+ i +"negate addmonths ";     :} | 
              SUBTRACT number:i DAYS   FROM dexpr:v  {: RESULT = v +" "+ i +"negate adddays ";       :} | 
              ADD      number:i YEARS  TO   dexpr:v  {: RESULT = v +" "+ i +"addyears ";             :} | 
              ADD      number:i MONTHS TO   dexpr:v  {: RESULT = v +" "+ i +"addmonths ";            :} | 
              ADD      number:i DAYS   TO   dexpr:v  {: RESULT = v +" "+ i +"adddays ";              :} |
			  
              dexpr:v MINUS  number:i YEARS           {: RESULT = v +" "+ i +"negate addyears ";     :} |
              dexpr:v MINUS  number:i MONTHS          {: RESULT = v +" "+ i +"negate addmonths ";    :} | 
              dexpr:v MINUS  number:i DAYS            {: RESULT = v +" "+ i +"negate adddays ";      :} | 
              dexpr:v PLUS   number:i YEARS           {: RESULT = v +" "+ i +"addyears ";            :} | 
              dexpr:v PLUS   number:i MONTHS          {: RESULT = v +" "+ i +"addmonths ";           :} | 
              dexpr:v PLUS   number:i DAYS            {: RESULT = v +" "+ i +"adddays ";             :} |
			  							             
//We match MONTHS and YEARS to both plural and singular 	
              FIRST OF YEARS OF dexpr:d              {: RESULT = d + "firstofyear ";                 :} |
			  FIRST OF MONTHS OF dexpr:d             {: RESULT = d + "firstofmonth ";                :} |
			  END OF MONTHS OF dexpr:d               {: RESULT = d + "endofmonth ";                  :} |

              // the earliest cutoffdate after the currentdate;
              // The postfix is a bit complicated.  I sort the array in decending order, then (starting with 
              // the given date) I run through all the dates in the list, and keeping only the dates after
              // the given date.  The one remaining is the last one, the earliest greater than the given date.
              // I use the control stack to make the logic a bit easier to follow.
  			  EARLIEST OF array_expr:a AFTER dexpr:d {: RESULT = d + "dup >r { { pop pop i i } over i d> if pop } "+a+"dup false sortarray for r> pop "; :} ;             

// Name expressions
nexpr    ::=  RNAME:n                     {: RESULT = n+" ";                                        :} |
              NAMEOF eexpr:e              {: RESULT = e+"getname ";                                 :} |
              THENAME strexpr:s           {: RESULT = s+"cvn ";                                     :} |
			  NAME RARRAY:ra LBRACE iexpr:ie1 RBRACE     {: RESULT = ra+" "+ie1+"getat ";       :} |
			  NAME:n                      {: RESULT = "/"+n+" ";                          :} |
	
              USING eexpr:ee  LPAREN nexpr:e RPAREN {: RESULT = ee + "entitypush "+e+"entitypop ";  :} |
              colonRef:e1 RNAME:n         {: RESULT = e1 +"entitypush "+n+" entitypop ";             :} |
              LPAREN NAME RPAREN strexpr:s {: RESULT = s+"cvn ";                                    :} ; 
              
 			        

tablelist ::= strexpr:s COMMA tablelist:t {: RESULT = s+t; 				    :} 
			  |
			  strexpr:s                   {: RESULT = s;    				:} ;

texpr    ::=  RTABLE:t                    {: RESULT = t+" ";                :} |
			  NEW strexpr TABLE OF strexpr:s
			  							  {: /**c**/ :};

strexpr  ::=  ATTRIBUTE strexpr:s OF eexpr:e
                                          {: RESULT = e+s+"getXmlAttribute "; :}
              |
              MAPPINGKEY                  {: RESULT = "\"mapping*key\" cvn execute "; :}
              |
              RXMLVALUE:s                 {: RESULT = s+" cvs ";                    :}
              |  
              RXMLVALUE:t COLON GET ATTRIBUTE strexpr:s                
                                          {: RESULT = t+s+"getXmlAttributeValue "; :}
              |
              SUBSTRING OF strexpr:s FROM iexpr:start TO iexpr:end
                                          {: RESULT = end+start+s+"substring "; :} 
              |                             
              TABLEINFORMATION            {: RESULT = "actionstring ";          :} 
              |  
			  STRING VALUE OF operatorstatements:o 
			  							  {: RESULT = o +"cvs ";                :}
              |
			  LPAREN STRING RPAREN texpr:t LPAREN tablelist:keys RPAREN 
			  							  {: RESULT = t + " " + keys + "lookup "; :}
			  |
			  RSTRING:s                   {: RESULT = s+" "; :}
			  |
              colonRef:e1 strexpr:s       {: RESULT = e1 +"entitypush "+s+"entitypop "; :}
              |
              STRING:s                    {: RESULT = s+" "; :}
              |
              strexpr:s1 PLUS strexpr:s2  {: RESULT = s1+s2+"strconcat "; :}
              |
              LPAREN STRING RPAREN fexpr:fe  {: RESULT = fe+"tostring ";   :}
              |
              LPAREN STRING RPAREN iexpr:ie  {: RESULT = ie+"tostring ";   :}
              |
              LPAREN STRING RPAREN dexpr:de  {: RESULT = de+"tostring ";   :}
              |
              CVS LPAREN bexpr:b RPAREN      {: RESULT = b+"tostring ";   :}
              |
              LPAREN strexpr:s RPAREN     {: RESULT = s;                :}
              |
              strexpr:s PLUS iexpr:e      {: RESULT = s+e+"strconcat "; :}
              |
              strexpr:s PLUS fexpr:e      {: RESULT = s+e+"strconcat "; :}
              |
              strexpr:s PLUS nexpr:e      {: RESULT = s+e+"strconcat "; :}
              |
              strexpr:s PLUS eexpr:e      {: RESULT = s+e+"strconcat "; :}
              |
              strexpr:s PLUS dexpr:e      {: RESULT = s+e+"strconcat "; :}
              |
              strexpr:s PLUS array_expr:e {: RESULT = s+e+"strconcat "; :}
              |
              strexpr:s PLUS RNULL:e      {: RESULT = s+e+" strconcat "; :}
              |
              strexpr:s PLUS RINVALID:e   {: RESULT = s+e+" strconcat "; :}
              |
              TRIM LPAREN strexpr:s RPAREN      {: RESULT = s+"strtrim "; :}
		      | 
			  LPAREN STRING RPAREN indx_expr:ie  {: RESULT = ie +"tostring "; :}	      
		      | 
			  CHANGE strexpr:se TO LOWER_CASE {: RESULT = se +"tolowercase "; :}	      
		      | 
			  CHANGE strexpr:se TO UPPER_CASE {: RESULT = se +"touppercase "; :}
			  |	      
			  GET CURRENT_DATE                        {: RESULT = "getdate ";                         :} 
			  |
			  GET CURRENT_TIMESTAMP                   {: RESULT = "gettimestamp ";                    :} 
			  |
              USING eexpr:ee  LPAREN strexpr:e RPAREN {: RESULT = ee + "entitypush "+e+"entitypop ";  :} 
              |
			  // relationship Syntax              
              RELATIONSHIP_BETWEEN eexpr:e1 AND eexpr:e2 {: RESULT = e1+e2+
              														 "{ type } { '' } "+ 
                                                                     "{ over source req { pop dup target req } over if } "+
                                                                     "relationships forfirstelse swap pop swap pop "; :} ;
                      

fexpr    ::=  FLOAT:n                     {: RESULT = n+" "; :}
              |
              colonRef:re RDOUBLE:f       {: RESULT = re+ "entitypush "+f+" entitypop "; :}
              | 
              RDOUBLE:e1                  {: RESULT = e1+" "; :}
              |
              LPAREN DOUBLE RPAREN strexpr:e1 {: RESULT = e1+"cvr "; :}
              |
              LPAREN DOUBLE RPAREN iexpr:e1   {: RESULT = e1+"cvr "; :}
              |
              LPAREN DOUBLE RPAREN RTABLE:t LPAREN tablelist:keys RPAREN {: RESULT = t + " " + keys + "lookup ";         :} 
              |
              fexpr:e1 PLUS iexpr:e2      {: RESULT = e1+e2+"fadd "; :}
              |
              fexpr:e1 PLUS fexpr:e2      {: RESULT = e1+e2+"fadd "; :}
              |
              iexpr:e1 PLUS fexpr:e2      {: RESULT = e1+e2+"fadd "; :}
              |
              fexpr:e1 MINUS iexpr:e2     {: RESULT = e1+e2+"fsub "; :}
              |
              iexpr:e1 MINUS fexpr:e2     {: RESULT = e1+e2+"fsub "; :}
              |
              fexpr:e1 MINUS fexpr:e2     {: RESULT = e1+e2+"fsub "; :}
              |
              fexpr:e1 TIMES iexpr:e2     {: RESULT = e1+e2+"fmul "; :}
              |
              iexpr:e1 TIMES fexpr:e2     {: RESULT = e1+e2+"fmul "; :}
              |
              fexpr:e1 TIMES fexpr:e2     {: RESULT = e1+e2+"fmul "; :}
              |
              fexpr:e1 DIVIDE iexpr:e2    {: RESULT = e1+e2+"fdiv "; :}
              |
              iexpr:e1 DIVIDE fexpr:e2    {: RESULT = e1+e2+"fdiv "; :}
              |
              fexpr:e1 DIVIDE fexpr:e2    {: RESULT = e1+e2+"fdiv "; :}
              |
              MINUS fexpr:e               {: RESULT = e+"fnegate "; :} 
     	      %prec UMINUS
              | 
              LPAREN fexpr:e RPAREN       {: RESULT = e; :} 
              |
			  LPAREN DOUBLE RPAREN indx_expr:ie  {: RESULT = ie; :}	      
              |
              ADD TO   RDOUBLE:v number:n           {: RESULT = "/"+n+" "+v+n+" fadd def "; :} |
              SUBTRACT FROM RDOUBLE:v number:n      {: RESULT = "/"+n+" "+v+n+" fsub def "; :} |
              MULTIPLY RDOUBLE:v BY number:n        {: RESULT = "/"+n+" "+v+n+" fmul def "; :} |
              DIVIDE   RDOUBLE:v BY number:n        {: RESULT = "/"+n+" "+v+n+" fdiv def "; :} |


              ABSOLUTEVALUE OF fexpr:n                  {: RESULT = n+"fabs ";                            :} |
              USING eexpr:ee  LPAREN fexpr:e RPAREN     {: RESULT = ee + "entitypush "+e+"entitypop ";    :} |
              DOUBLE VALUE OF operatorstatements:e      {: RESULT = e;                                    :} |
                                                        
              fexpr:n ROUNDED                           {: RESULT = n+"0 0.5 roundto ";                   :} |
              fexpr:n ROUNDED TO iexpr:i DECIMAL_PLACES {: RESULT = n+i+"0.5 roundto ";                   :} |
              fexpr:n ROUNDED TO iexpr:i DECIMAL_PLACES WITH_BOUNDRY fexpr:b
                                                        {: RESULT = n+i+b+" roundto ";                    :} |
              SUM_OF fexpr:f IN array_expr:a            {: RESULT = "0 { "+f+"ladd } "+a+"forall ";       :} ;
                                                        



iexpr     ::= iexpr:e1 PLUS iexpr:e2   {: RESULT = e1+e2+"+ "; :} 
	      | 
              iexpr:e1 MINUS iexpr:e2  {: RESULT = e1+e2+"- "; :} 
	      | 
              iexpr:e1 TIMES iexpr:e2  {: RESULT = e1+e2+"* "; :} 
	      | 
              iexpr:e1 DIVIDE iexpr:e2 {: RESULT = e1+e2+"div "; :} 
	      | 
              INTEGER:n                {: RESULT = n+" "; :} 
	      | 
              MINUS iexpr:e            {: RESULT = e+"negate "; :} 
	      %prec UMINUS
	      | 
           LPAREN iexpr:e RPAREN       {: RESULT = e+" "; :} 
          |
          RLONG:e1                     {: RESULT = e1+" "; :}
          | 
          GET DAYS IN YEAROF dexpr:de  {: RESULT = de + "getdaysinyear ";        :} 
          |
          GET DAYS IN MONTHS FOR dexpr:d   {: RESULT = d + "getdaysinmonth ";        :}
          |
          GET DAYS OF MONTHS FOR dexpr:d   {: RESULT = d + "getdayofmonth ";         :}
          |
           colonRef:re RLONG:n             {: RESULT = re+ "entitypush "+n+" entitypop "; :}
	      | 
		   LPAREN LONG RPAREN indx_expr:ie  {: RESULT = ie + "cvi "; :}	      
	      | 
		   LPAREN LONG RPAREN strexpr:ie    {: RESULT = ie + "cvi "; :}
		  |
		   LPAREN LONG RPAREN number:ie     {: RESULT = ie + "cvi "; :}	      
		  | 
		   LPAREN LONG RPAREN RTABLE:t LPAREN tablelist:keys RPAREN {: RESULT = t + " " + keys + "lookup ";         :} 		   
	      | 
	       NUMBEROF  array_expr:a                {: RESULT = a+"length ";                              :} |
	       NUMBEROF  array_expr:a WHERE bexpr:b  {: RESULT = "0 { { 1 ladd } "+b+"if }"+a+"forall ";   :} |
           LENGTH OF array_expr:a                {: RESULT = a+"length ";                              :} |
           LENGTH OF strexpr:s                   {: RESULT = s+"strlength ";                           :} |
           INDEX_OF strexpr:s1 IN strexpr:s2     {: RESULT = s1+s2+"indexof ";                         :} |
           
           USING array_expr:ee number:e          {: RESULT = ee+"entitypush "+e+"entitypop "; :} |
           
           ADD TO RLONG:v number:n               {: RESULT = "/"+n+v+n+" ladd def "; :} |
           SUBTRACT FROM RLONG:v number:n        {: RESULT = "/"+n+v+n+" lsub def "; :} |
           MULTIPLY RLONG:v BY number:n          {: RESULT = "/"+n+v+n+" lmul def "; :} |
           DIVIDE   RLONG:v BY number:n          {: RESULT = "/"+n+v+n+" ldiv def "; :} |
                      
           ABSOLUTEVALUE OF iexpr:n              {: RESULT = n+"labs ";                         :} |
           USING eexpr:ee  LPAREN iexpr:e RPAREN {: RESULT = ee + "entitypush "+e+"entitypop "; :} |
           DAYS   FROM dexpr:d1 TO dexpr:d2      {: RESULT = d1+d2+"daysbetween ";              :} |
           MONTHS FROM dexpr:d1 TO dexpr:d2      {: RESULT = d1+d2+"monthsbetween ";            :} |
           YEARS  FROM dexpr:d1 TO dexpr:d2      {: RESULT = d1+d2+"yearsbetween ";             :} |
           GET YEAROF dexpr:d1                   {: RESULT = d1+"yearof ";                      :} |
           LONG VALUE OF operatorstatements:e    {: RESULT = e;                                 :} |
           SUM_OF iexpr:i IN array_expr:a        {: RESULT = "0 { "+i+"ladd } "+a+"forall ";    :} ;
     

includeSearch ::= VALUE number:e	{: RESULT = e; :} |
			      DATE dexpr:e		{: RESULT = e; :} |
			      eexpr:e   		{: RESULT = e; :} |
			      STRING strexpr:e 	{: RESULT = e; :} ;
			      
inthe     ::= IN | FOR | ON;		


thereis  ::=  THERE IS |
		      IS THERE;

blist     ::= strexpr:s COMMA  blist:bl    {: RESULT = "dup "+s+"streq { pop "+bl+"} over not if "; :} |
              OR strexpr:s                 {: RESULT = "dup "+s+"streq ";                           :} ;	            

// Compare a list, ignoring the case
blist_ic     ::= strexpr:s COMMA  blist:bl {: RESULT = "dup "+s+"sic== { pop "+bl+"} over not if "; :} |
              OR strexpr:s                 {: RESULT = "dup "+s+"sic== ";                           :} ;                

     
bexpr     ::= 		
			// Complicated Tests
			// array does not include integer/string/float/entity
			array_expr:a DOES NOT INCLUDE includeSearch:e {: RESULT = a+e+"memberof not "; 				:}  |
			array_expr:a DOES INCLUDE includeSearch:e     {: RESULT = a+e+"memberof ";    				:}  |
            array_expr:a INCLUDES includeSearch:e         {: RESULT = a+e+"memberof ";    				:}  |

            // This syntax looks for a match for each string in a1 to an
            // attribute n on some entity in an array of entities a2
            thereis MATCH FORALL array_expr:a1 TO nexpr:n IN array_expr:a2
                    {: RESULT = "true { over { { } { swap pop false swap } { dup "+n+"execute streq } "+a2+"forfirstelse } swap if pop } "+a1+"for "; :} |                    
			// Is there a case_indvidual [ in the case ]  Where  case_indvidual.current_plan_available == false 
			thereis eexpr:e1 WHERE bexpr:b 				
					{: RESULT = "{ true } { false } { " + b +"} "+e1.trim()+"s forfirstelse ";                            :} |
			thereis eexpr:e1 inthe eexpr:e2 WHERE bexpr:b 	
					{: RESULT = "{ true } { false } { " + b +"} "+e1.trim()+"s "+e2+"entitypush forfirstelse entitypop "; :} |
			thereis eexpr:e1 inthe array_expr:a WHERE bexpr:b    
                    {: RESULT = "{ true } { false } { " + b +"} "+a+ " forfirstelse ";                                    :} |
            
			
			THERE IS NO eexpr:e1 WHERE bexpr:b					
				    {: RESULT = "{ false } { true } { " + b +"} "+e1.trim()+"s forfirstelse ";                            :} |
			THERE IS NO eexpr:e1 inthe eexpr:e2 WHERE bexpr:b 	
					{: RESULT = "{ false } { true } { " + b +"} "+e1.trim()+"s "+e2+"entitypush forfirstelse entitypop "; :} |
            THERE IS NO eexpr:e1 inthe array_expr:a WHERE bexpr:b   
                    {: RESULT = "{ false } { true } { " + b +"} "+a+"forfirstelse "; :} |
            // all initialdeterminations have an eligibility == Denied_Out_of_Age_Limit
            ALL array_expr:a HAVE bexpr:b
                    {: RESULT = "{ false } { true } { " + b +"not } "+a+"forfirstelse "; :} |
            ONE OF array_expr:a HASA bexpr:b
                    {: RESULT = "{ true } { false } { " + b +"} "+a+"forfirstelse "; :} |
                    
            // relationship Syntax
            //                
			// Relationship tests.  These tests assume that a relationships list exists within the context,
			// and that a Relationship entity is defined.  This relationship entity must have the following
			// attributes:
			//       entity source   -- This is the source entity
			//       entity target   -- This is the target entity
			//       String type	 -- This is the type, like child.  source is a child of target			
			
			eexpr:e DOES NOT HAVE strexpr:s				{: RESULT = s + e +"{ pop pop false } { pop pop true } "+
			                                               "{ over type streq over target req and } relationships forfirstelse "; :} | 

			eexpr:e HASA strexpr:s		                {: RESULT = s + e +"{ pop pop true } { pop pop false } "+
			                                               "{ over type streq over target req and } relationships forfirstelse "; :} | 

			eexpr:e HASA strexpr:s WHERE bexpr:b        {: RESULT = s + e +"{ pop pop true } { pop pop false } "+
			                                               "{ over type streq over target req and "+
			                                               "source entitypush "+b+"entitypop and } relationships forfirstelse "; :} | 

			eexpr:e1 IS strexpr:s OF eexpr:e2		//	{: RESULT = s + "{ pop true } { pop false } "+
													//	   "{ dup type streq source "+e1+" req and target "+e2+" req and } "+
													//	   " relationships forfirstelse "; :}                                       |
													
				    			                        {: RESULT = "/source "+e1+"/target "+e2+"/type "+s+"relationships findmatch swap pop"; :} | 
				    			
				    			
// Numbers
              fexpr:n1 IS WITHIN number:percent PERCENTOF fexpr:n2     
                      {: RESULT = n2+n1+percent+"100.0 f/ over f* swap >r >r >r i j f- k f< r> r> f+ r> f> and ";   :}
              |
              fexpr:n1 IS PLUSORMINUS number:err OF fexpr:n2           
                      {: RESULT = n2+err+n1+                          ">r >r >r i j f- k f< r> r> f+ r> f> and ";   :}
              |
              iexpr:e1 EQ iexpr:e2     {: RESULT = e1+e2+"== "; :}
              |
              fexpr:e1 EQ iexpr:e2     {: RESULT = e1+e2+"f== "; :}
              |
              iexpr:e1 EQ fexpr:e2     {: RESULT = e1+e2+"f== "; :}
              |
              fexpr:e1 EQ fexpr:e2     {: RESULT = e1+e2+"f== "; :}
              |
              
              iexpr:e1 NEQ iexpr:e2     {: RESULT = e1+e2+"== not "; :}
              |
              fexpr:e1 NEQ iexpr:e2     {: RESULT = e1+e2+"f== not "; :}
              |
              iexpr:e1 NEQ fexpr:e2     {: RESULT = e1+e2+"f== not "; :}
              |
              fexpr:e1 NEQ fexpr:e2     {: RESULT = e1+e2+"f== not "; :}
              |

              iexpr:e1 GT iexpr:e2     {: RESULT = e1+e2+"> "; :}
              |
              fexpr:e1 GT iexpr:e2     {: RESULT = e1+e2+"f> "; :}
              |
              iexpr:e1 GT fexpr:e2     {: RESULT = e1+e2+"f> "; :}
              |
              fexpr:e1 GT fexpr:e2     {: RESULT = e1+e2+"f> "; :}
              | 

              iexpr:e1 GTE iexpr:e2    {: RESULT = e1+e2+">= "; :}
              |
              fexpr:e1 GTE iexpr:e2    {: RESULT = e1+e2+"f>= "; :}
              |
              iexpr:e1 GTE fexpr:e2    {: RESULT = e1+e2+"f>= "; :}
              |
              fexpr:e1 GTE fexpr:e2    {: RESULT = e1+e2+"f>= "; :}
              |

              iexpr:e1 LT iexpr:e2     {: RESULT = e1+e2+"< "; :}
              |
              fexpr:e1 LT iexpr:e2     {: RESULT = e1+e2+"f< "; :}
              |
              iexpr:e1 LT fexpr:e2     {: RESULT = e1+e2+"f< "; :}
              |
              fexpr:e1 LT fexpr:e2     {: RESULT = e1+e2+"f< "; :}
              | 

              iexpr:e1 LTE iexpr:e2    {: RESULT = e1+e2+"<= "; :}
              |
              fexpr:e1 LTE iexpr:e2    {: RESULT = e1+e2+"f<= "; :}
              |
              iexpr:e1 LTE fexpr:e2    {: RESULT = e1+e2+"f<= "; :}
              |
              fexpr:e1 LTE fexpr:e2    {: RESULT = e1+e2+"f<= "; :}
              |
    
              RBOOLEAN:e1              {: RESULT = e1+" "; :}
              | 
              colonRef:re RBOOLEAN:b   {: RESULT = re+ "entitypush "+b+" entitypop "; :}
              
// Names
              |
              nexpr:n1 EQ nexpr:n2     {: RESULT = n1+n2+"nameeq "; :}
              | 
              nexpr:n  EQ strexpr:s    {: RESULT = n+s+"streq "; :}
              |

              nexpr:n1 NEQ nexpr:n2     {: RESULT = n1+n2+"nameeq not "; :}
              | 
              nexpr:n  NEQ strexpr:s    {: RESULT = n+s+"streq not "; :}
              |

// Strings
              strexpr:s EQ_IGNORE_CASE blist_ic:bl  
                                         {: RESULT = s+bl+"swap drop ";        :}
              |
              strexpr:s EQ blist:bl      {: RESULT = s+bl+"swap drop ";        :}
              |              
              strexpr:s1 EQ  strexpr:s2  {: RESULT = s1+s2+"streq ";           :}
              |
              strexpr:s1 NEQ strexpr:s2  {: RESULT = s1+s2+"streq not ";       :}
              |
              strexpr:s1 EQ_IGNORE_CASE  strexpr:s2  {: RESULT = s1+s2+"sic== ";           :}
              |
              strexpr:s1 NEQ_IGNORE_CASE strexpr:s2  {: RESULT = s1+s2+"sic== not ";       :}
              |
              strexpr:s1 AT iexpr:e1 STARTS_WITH strexpr:s2
                                         {: RESULT = s1+s2+e1+"startswith ";   :}
              |
              strexpr:s1 STARTS_WITH strexpr:s2
                                         {: RESULT = s1+s2+"0 startswith ";    :}
              |          
			  strexpr:s1 IS ONE OF array_expr:a
			                             {: RESULT = a+s1+"memberof ";         :}
			  |
			  strexpr:s1 IS NOT ONE OF array_expr:a
			                             {: RESULT = a+s1+"memberof not ";     :}
              |
              DOES bexpr:e QUESTIONMARK  {: RESULT = e; :}
              |
              IS bexpr:e QUESTIONMARK    {: RESULT = e; :}
              |
              WAS bexpr:e QUESTIONMARK   {: RESULT = e; :}
              |
// String Compares
              strexpr:s1 GT strexpr:s2                      {: RESULT = s1+s2+"s> ";    :} |
              strexpr:s1 LT strexpr:s2                      {: RESULT = s1+s2+"s< "; 	:} |
              strexpr:s1 GTE strexpr:s2                      {: RESULT = s1+s2+"s>= ";  :} |
              strexpr:s1 LTE strexpr:s2                      {: RESULT = s1+s2+"s<= "; 	:} |

// Regex Compare
              strexpr:s1 MATCHES strexpr:e1           {: RESULT = e1+s1+"regexmatch "; :} 
              |

// Boolean tests
              bexpr:e1 EQ bexpr:e2     {: RESULT = e1+e2+"beq "; :}
              |
              bexpr:e1 NEQ bexpr:e2    {: RESULT = e1+e2+"beq "; :}
              |
              bexpr:e1 AND bexpr:e2    {: RESULT = e1+"{ pop "+e2+"} over if\n"; :} 
              |
              bexpr:e1 OR bexpr:e2     {: RESULT = e1+"{ pop "+e2+"} over not if\n"; :}
              |
              NOT bexpr:e              {: RESULT = e+"not "; :}  
              |
              
// Null Tests              
              bexpr:s ISNULL                        {: RESULT = s+" isnull "; :}
              |
              bexpr:s ISNOTNULL                     {: RESULT = s+" isnull not "; :}
              |
              number:s ISNULL                       {: RESULT = s+" isnull "; :}
              |
              number:s ISNOTNULL                    {: RESULT = s+" isnull not "; :}
              |
              dexpr:s ISNULL                        {: RESULT = s+" isnull "; :}
              |
              array_expr:s ISNULL                   {: RESULT = s+" isnull "; :}
              |
              strexpr:s ISNULL                      {: RESULT = s+" isnull "; :}
              |
              eexpr:s ISNULL                        {: RESULT = s+" isnull "; :}
              |
              dexpr:s ISNOTNULL                     {: RESULT = s+" isnull not "; :}
              |
              array_expr:s ISNOTNULL                {: RESULT = s+" isnull not "; :}
              |
              strexpr:s ISNOTNULL                   {: RESULT = s+" isnull not "; :}
              |
              eexpr:s ISNOTNULL                     {: RESULT = s+" isnull not "; :}
              |
              USING eexpr:ee LPAREN bexpr:e RPAREN  {: RESULT = ee + "entitypush "+e+"entitypop "; :}
              |
              LPAREN bexpr:e RPAREN                 {: RESULT = e; :}
              |
		      LPAREN BOOLEAN RPAREN indx_expr:ie    {: RESULT = ie; :}	      
//              |
//		      LPAREN BOOLEAN RPAREN anytype:ie      {: RESULT = ie; :}
              |
              LPAREN BOOLEAN RPAREN strexpr:s       {: RESULT = s+"cvb "; :}	      
              |
                   
			  BOOLEAN RARRAY:ra LBRACE iexpr:ie1 RBRACE {: RESULT = ra+" "+ie1+"getat "; :}
              |
 
// Date Compares
              dexpr:d1 EQ dexpr:d2                      {: RESULT = d1+d2+"d== ";                           	:} |
              dexpr:d1 LT dexpr:d2                      {: RESULT = d1+d2+"d< "; 								:} |		
              dexpr:d1 IS BEFORE dexpr:d2               {: RESULT = d1+d2+"d< "; 								:} |
              dexpr:d1 GT dexpr:d2                      {: RESULT = d1+d2+"d> ";                             	:} |
              dexpr:d1 IS AFTER dexpr:d2                {: RESULT = d1+d2+"d> "; 								:} |
              dexpr:d1 GTE dexpr:d2                     {: RESULT = d1+d2+"d< not ";                          	:} |
              dexpr:d1 LTE dexpr:d2                     {: RESULT = d1+d2+"d> not ";                          	:} |
              dexpr:d1 IS BETWEEN dexpr:d2 AND dexpr:d3 {: RESULT = d2+d1+"d> not "+d1+d3+" d> not and ";       :} |

// Entity Compares
              eexpr:e1 EQ  eexpr:e2                      {: RESULT = e1+e2+"req  ";                                :} |
              eexpr:e1 NEQ eexpr:e2                      {: RESULT = e1+e2+"req not ";                             :} |
              // EntityX is in the context

              RENTITY:e ENTITY IS NOT IN CONTEXT         {: RESULT = "/"+e+" InContext not ";                     :} |   
              RENTITY:e ENTITY IS IN CONTEXT             {: RESULT = "/"+e+" InContext ";                         :} |   
              strexpr:s1 ENTITY IS IN CONTEXT            {: RESULT = s1+" InContext ";                             :} | 
              strexpr:s1 ENTITY IS NOT IN CONTEXT        {: RESULT = s1+" InContext not ";                         :} | 
              
              
// Rather random tests
              BOOLEAN VALUE OF operatorstatements:e      {: RESULT = e;                                            :} |

              BOOL_FUNCTION:b                            {: RESULT = b+" ";                                        :} ;                                                      


